Help on class FastMCP in module fastmcp.server.server:

class FastMCP(typing.Generic)
 |  FastMCP(name: 'str | None' = None, instructions: 'str | None' = None, *, version: 'str | None' = None, website_url: 'str | None' = None, icons: 'list[mcp.types.Icon] | None' = None, auth: 'AuthProvider | NotSetT | None' = Ellipsis, middleware: 'Sequence[Middleware] | None' = None, lifespan: 'LifespanCallable | None' = None, mask_error_details: 'bool | None' = None, tools: 'Sequence[Tool | Callable[..., Any]] | None' = None, tool_transformations: 'Mapping[str, ToolTransformConfig] | None' = None, tool_serializer: 'ToolResultSerializerType | None' = None, include_tags: 'Collection[str] | None' = None, exclude_tags: 'Collection[str] | None' = None, include_fastmcp_meta: 'bool | None' = None, on_duplicate_tools: 'DuplicateBehavior | None' = None, on_duplicate_resources: 'DuplicateBehavior | None' = None, on_duplicate_prompts: 'DuplicateBehavior | None' = None, strict_input_validation: 'bool | None' = None, tasks: 'bool | None' = None, log_level: 'str | None' = None, debug: 'bool | None' = None, host: 'str | None' = None, port: 'int | None' = None, sse_path: 'str | None' = None, message_path: 'str | None' = None, streamable_http_path: 'str | None' = None, json_response: 'bool | None' = None, stateless_http: 'bool | None' = None, sampling_handler: 'SamplingHandler | None' = None, sampling_handler_behavior: "Literal['always', 'fallback'] | None" = None)
 |  
 |  Method resolution order:
 |      FastMCP
 |      typing.Generic
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, name: 'str | None' = None, instructions: 'str | None' = None, *, version: 'str | None' = None, website_url: 'str | None' = None, icons: 'list[mcp.types.Icon] | None' = None, auth: 'AuthProvider | NotSetT | None' = Ellipsis, middleware: 'Sequence[Middleware] | None' = None, lifespan: 'LifespanCallable | None' = None, mask_error_details: 'bool | None' = None, tools: 'Sequence[Tool | Callable[..., Any]] | None' = None, tool_transformations: 'Mapping[str, ToolTransformConfig] | None' = None, tool_serializer: 'ToolResultSerializerType | None' = None, include_tags: 'Collection[str] | None' = None, exclude_tags: 'Collection[str] | None' = None, include_fastmcp_meta: 'bool | None' = None, on_duplicate_tools: 'DuplicateBehavior | None' = None, on_duplicate_resources: 'DuplicateBehavior | None' = None, on_duplicate_prompts: 'DuplicateBehavior | None' = None, strict_input_validation: 'bool | None' = None, tasks: 'bool | None' = None, log_level: 'str | None' = None, debug: 'bool | None' = None, host: 'str | None' = None, port: 'int | None' = None, sse_path: 'str | None' = None, message_path: 'str | None' = None, streamable_http_path: 'str | None' = None, json_response: 'bool | None' = None, stateless_http: 'bool | None' = None, sampling_handler: 'SamplingHandler | None' = None, sampling_handler_behavior: "Literal['always', 'fallback'] | None" = None)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__(self) -> 'str'
 |      Return repr(self).
 |  
 |  add_middleware(self, middleware: 'Middleware') -> 'None'
 |  
 |  add_prompt(self, prompt: 'Prompt') -> 'Prompt'
 |      Add a prompt to the server.
 |      
 |      Args:
 |          prompt: A Prompt instance to add
 |      
 |      Returns:
 |          The prompt instance that was added to the server.
 |  
 |  add_resource(self, resource: 'Resource') -> 'Resource'
 |      Add a resource to the server.
 |      
 |      Args:
 |          resource: A Resource instance to add
 |      
 |      Returns:
 |          The resource instance that was added to the server.
 |  
 |  add_template(self, template: 'ResourceTemplate') -> 'ResourceTemplate'
 |      Add a resource template to the server.
 |      
 |      Args:
 |          template: A ResourceTemplate instance to add
 |      
 |      Returns:
 |          The template instance that was added to the server.
 |  
 |  add_tool(self, tool: 'Tool') -> 'Tool'
 |      Add a tool to the server.
 |      
 |      The tool function can optionally request a Context object by adding a parameter
 |      with the Context type annotation. See the @tool decorator for examples.
 |      
 |      Args:
 |          tool: The Tool instance to register
 |      
 |      Returns:
 |          The tool instance that was added to the server.
 |  
 |  add_tool_transformation(self, tool_name: 'str', transformation: 'ToolTransformConfig') -> 'None'
 |      Add a tool transformation.
 |  
 |  custom_route(self, path: 'str', methods: 'list[str]', name: 'str | None' = None, include_in_schema: 'bool' = True) -> 'Callable[[Callable[[Request], Awaitable[Response]]], Callable[[Request], Awaitable[Response]]]'
 |      Decorator to register a custom HTTP route on the FastMCP server.
 |      
 |      Allows adding arbitrary HTTP endpoints outside the standard MCP protocol,
 |      which can be useful for OAuth callbacks, health checks, or admin APIs.
 |      The handler function must be an async function that accepts a Starlette
 |      Request and returns a Response.
 |      
 |      Args:
 |          path: URL path for the route (e.g., "/auth/callback")
 |          methods: List of HTTP methods to support (e.g., ["GET", "POST"])
 |          name: Optional name for the route (to reference this route with
 |              Starlette's reverse URL lookup feature)
 |          include_in_schema: Whether to include in OpenAPI schema, defaults to True
 |      
 |      Example:
 |          Register a custom HTTP route for a health check endpoint:
 |          ```python
 |          @server.custom_route("/health", methods=["GET"])
 |          async def health_check(request: Request) -> Response:
 |              return JSONResponse({"status": "ok"})
 |          ```
 |  
 |  async get_prompt(self, key: 'str') -> 'Prompt'
 |  
 |  async get_prompts(self) -> 'dict[str, Prompt]'
 |      Get all prompts (unfiltered), including mounted servers, indexed by key.
 |  
 |  async get_resource(self, key: 'str') -> 'Resource'
 |  
 |  async get_resource_template(self, key: 'str') -> 'ResourceTemplate'
 |      Get a registered resource template by key.
 |  
 |  async get_resource_templates(self) -> 'dict[str, ResourceTemplate]'
 |      Get all resource templates (unfiltered), including mounted servers, indexed by key.
 |  
 |  async get_resources(self) -> 'dict[str, Resource]'
 |      Get all resources (unfiltered), including mounted servers, indexed by key.
 |  
 |  async get_tool(self, key: 'str') -> 'Tool'
 |  
 |  async get_tools(self) -> 'dict[str, Tool]'
 |      Get all tools (unfiltered), including mounted servers, indexed by key.
 |  
 |  http_app(self, path: 'str | None' = None, middleware: 'list[ASGIMiddleware] | None' = None, json_response: 'bool | None' = None, stateless_http: 'bool | None' = None, transport: "Literal['http', 'streamable-http', 'sse']" = 'http', event_store: 'EventStore | None' = None, retry_interval: 'int | None' = None) -> 'StarletteWithLifespan'
 |      Create a Starlette app using the specified HTTP transport.
 |      
 |      Args:
 |          path: The path for the HTTP endpoint
 |          middleware: A list of middleware to apply to the app
 |          json_response: Whether to use JSON response format
 |          stateless_http: Whether to use stateless mode (new transport per request)
 |          transport: Transport protocol to use - "http", "streamable-http", or "sse"
 |          event_store: Optional event store for SSE polling/resumability. When set,
 |              enables clients to reconnect and resume receiving events after
 |              server-initiated disconnections. Only used with streamable-http transport.
 |          retry_interval: Optional retry interval in milliseconds for SSE polling.
 |              Controls how quickly clients should reconnect after server-initiated
 |              disconnections. Requires event_store to be set. Only used with
 |              streamable-http transport.
 |      
 |      Returns:
 |          A Starlette application configured with the specified transport
 |  
 |  async import_server(self, server: 'FastMCP[LifespanResultT]', prefix: 'str | None' = None) -> 'None'
 |      Import the MCP objects from another FastMCP server into this one,
 |      optionally with a given prefix.
 |      
 |      Note that when a server is *imported*, its objects are immediately
 |      registered to the importing server. This is a one-time operation and
 |      future changes to the imported server will not be reflected in the
 |      importing server. Server-level configurations and lifespans are not imported.
 |      
 |      When a server is imported with a prefix:
 |      - The tools are imported with prefixed names
 |        Example: If server has a tool named "get_weather", it will be
 |        available as "prefix_get_weather"
 |      - The resources are imported with prefixed URIs using the new format
 |        Example: If server has a resource with URI "weather://forecast", it will
 |        be available as "weather://prefix/forecast"
 |      - The templates are imported with prefixed URI templates using the new format
 |        Example: If server has a template with URI "weather://location/{id}", it will
 |        be available as "weather://prefix/location/{id}"
 |      - The prompts are imported with prefixed names
 |        Example: If server has a prompt named "weather_prompt", it will be available as
 |        "prefix_weather_prompt"
 |      
 |      When a server is imported without a prefix (prefix=None), its tools, resources,
 |      templates, and prompts are imported with their original names.
 |      
 |      Args:
 |          server: The FastMCP server to import
 |          prefix: Optional prefix to use for the imported server's objects. If None,
 |              objects are imported with their original names.
 |  
 |  mount(self, server: 'FastMCP[LifespanResultT]', prefix: 'str | None' = None, as_proxy: 'bool | None' = None, tool_names: 'dict[str, str] | None' = None) -> 'None'
 |      Mount another FastMCP server on this server with an optional prefix.
 |      
 |      Unlike importing (with import_server), mounting establishes a dynamic connection
 |      between servers. When a client interacts with a mounted server's objects through
 |      the parent server, requests are forwarded to the mounted server in real-time.
 |      This means changes to the mounted server are immediately reflected when accessed
 |      through the parent.
 |      
 |      When a server is mounted with a prefix:
 |      - Tools from the mounted server are accessible with prefixed names.
 |        Example: If server has a tool named "get_weather", it will be available as "prefix_get_weather".
 |      - Resources are accessible with prefixed URIs.
 |        Example: If server has a resource with URI "weather://forecast", it will be available as
 |        "weather://prefix/forecast".
 |      - Templates are accessible with prefixed URI templates.
 |        Example: If server has a template with URI "weather://location/{id}", it will be available
 |        as "weather://prefix/location/{id}".
 |      - Prompts are accessible with prefixed names.
 |        Example: If server has a prompt named "weather_prompt", it will be available as
 |        "prefix_weather_prompt".
 |      
 |      When a server is mounted without a prefix (prefix=None), its tools, resources, templates,
 |      and prompts are accessible with their original names. Multiple servers can be mounted
 |      without prefixes, and they will be tried in order until a match is found.
 |      
 |      There are two modes for mounting servers:
 |      1. Direct mounting (default when server has no custom lifespan): The parent server
 |         directly accesses the mounted server's objects in-memory for better performance.
 |         In this mode, no client lifecycle events occur on the mounted server, including
 |         lifespan execution.
 |      
 |      2. Proxy mounting (default when server has a custom lifespan): The parent server
 |         treats the mounted server as a separate entity and communicates with it via a
 |         Client transport. This preserves all client-facing behaviors, including lifespan
 |         execution, but with slightly higher overhead.
 |      
 |      Args:
 |          server: The FastMCP server to mount.
 |          prefix: Optional prefix to use for the mounted server's objects. If None,
 |              the server's objects are accessible with their original names.
 |          as_proxy: Whether to treat the mounted server as a proxy. If None (default),
 |              automatically determined based on whether the server has a custom lifespan
 |              (True if it has a custom lifespan, False otherwise).
 |          tool_names: Optional mapping of original tool names to custom names. Use this
 |              to override prefixed names. Keys are the original tool names from the
 |              mounted server.
 |  
 |  prompt(self, name_or_fn: 'str | AnyFunction | None' = None, *, name: 'str | None' = None, title: 'str | None' = None, description: 'str | None' = None, icons: 'list[mcp.types.Icon] | None' = None, tags: 'set[str] | None' = None, enabled: 'bool | None' = None, meta: 'dict[str, Any] | None' = None, task: 'bool | TaskConfig | None' = None) -> 'Callable[[AnyFunction], FunctionPrompt] | FunctionPrompt'
 |      Decorator to register a prompt.
 |      
 |              Prompts can optionally request a Context object by adding a parameter with the
 |              Context type annotation. The context provides access to MCP capabilities like
 |              logging, progress reporting, and session information.
 |      
 |              This decorator supports multiple calling patterns:
 |              - @server.prompt (without parentheses)
 |              - @server.prompt() (with empty parentheses)
 |              - @server.prompt("custom_name") (with name as first argument)
 |              - @server.prompt(name="custom_name") (with name as keyword argument)
 |              - server.prompt(function, name="custom_name") (direct function call)
 |      
 |              Args:
 |                  name_or_fn: Either a function (when used as @prompt), a string name, or None
 |                  name: Optional name for the prompt (keyword-only, alternative to name_or_fn)
 |                  description: Optional description of what the prompt does
 |                  tags: Optional set of tags for categorizing the prompt
 |                  enabled: Optional boolean to enable or disable the prompt
 |                  meta: Optional meta information about the prompt
 |      
 |              Examples:
 |      
 |                  ```python
 |                  @server.prompt
 |                  def analyze_table(table_name: str) -> list[Message]:
 |                      schema = read_table_schema(table_name)
 |                      return [
 |                          {
 |                              "role": "user",
 |                              "content": f"Analyze this schema:
 |      {schema}"
 |                          }
 |                      ]
 |      
 |                  @server.prompt()
 |                  async def analyze_with_context(table_name: str, ctx: Context) -> list[Message]:
 |                      await ctx.info(f"Analyzing table {table_name}")
 |                      schema = read_table_schema(table_name)
 |                      return [
 |                          {
 |                              "role": "user",
 |                              "content": f"Analyze this schema:
 |      {schema}"
 |                          }
 |                      ]
 |      
 |                  @server.prompt("custom_name")
 |                  async def analyze_file(path: str) -> list[Message]:
 |                      content = await read_file(path)
 |                      return [
 |                          {
 |                              "role": "user",
 |                              "content": {
 |                                  "type": "resource",
 |                                  "resource": {
 |                                      "uri": f"file://{path}",
 |                                      "text": content
 |                                  }
 |                              }
 |                          }
 |                      ]
 |      
 |                  @server.prompt(name="custom_name")
 |                  def another_prompt(data: str) -> list[Message]:
 |                      return [{"role": "user", "content": data}]
 |      
 |                  # Direct function call
 |                  server.prompt(my_function, name="custom_name")
 |                  ```
 |  
 |  remove_tool(self, name: 'str') -> 'None'
 |      Remove a tool from the server.
 |      
 |      Args:
 |          name: The name of the tool to remove
 |      
 |      Raises:
 |          NotFoundError: If the tool is not found
 |  
 |  remove_tool_transformation(self, tool_name: 'str') -> 'None'
 |      Remove a tool transformation.
 |  
 |  resource(self, uri: 'str', *, name: 'str | None' = None, title: 'str | None' = None, description: 'str | None' = None, icons: 'list[mcp.types.Icon] | None' = None, mime_type: 'str | None' = None, tags: 'set[str] | None' = None, enabled: 'bool | None' = None, annotations: 'Annotations | dict[str, Any] | None' = None, meta: 'dict[str, Any] | None' = None, task: 'bool | TaskConfig | None' = None) -> 'Callable[[AnyFunction], Resource | ResourceTemplate]'
 |      Decorator to register a function as a resource.
 |      
 |      The function will be called when the resource is read to generate its content.
 |      The function can return:
 |      - str for text content
 |      - bytes for binary content
 |      - other types will be converted to JSON
 |      
 |      Resources can optionally request a Context object by adding a parameter with the
 |      Context type annotation. The context provides access to MCP capabilities like
 |      logging, progress reporting, and session information.
 |      
 |      If the URI contains parameters (e.g. "resource://{param}") or the function
 |      has parameters, it will be registered as a template resource.
 |      
 |      Args:
 |          uri: URI for the resource (e.g. "resource://my-resource" or "resource://{param}")
 |          name: Optional name for the resource
 |          description: Optional description of the resource
 |          mime_type: Optional MIME type for the resource
 |          tags: Optional set of tags for categorizing the resource
 |          enabled: Optional boolean to enable or disable the resource
 |          annotations: Optional annotations about the resource's behavior
 |          meta: Optional meta information about the resource
 |      
 |      Examples:
 |          Register a resource with a custom name:
 |          ```python
 |          @server.resource("resource://my-resource")
 |          def get_data() -> str:
 |              return "Hello, world!"
 |      
 |          @server.resource("resource://my-resource")
 |          async get_data() -> str:
 |              data = await fetch_data()
 |              return f"Hello, world! {data}"
 |      
 |          @server.resource("resource://{city}/weather")
 |          def get_weather(city: str) -> str:
 |              return f"Weather for {city}"
 |      
 |          @server.resource("resource://{city}/weather")
 |          async def get_weather_with_context(city: str, ctx: Context) -> str:
 |              await ctx.info(f"Fetching weather for {city}")
 |              return f"Weather for {city}"
 |      
 |          @server.resource("resource://{city}/weather")
 |          async def get_weather(city: str) -> str:
 |              data = await fetch_weather(city)
 |              return f"Weather for {city}: {data}"
 |          ```
 |  
 |  run(self, transport: 'Transport | None' = None, show_banner: 'bool' = True, **transport_kwargs: 'Any') -> 'None'
 |      Run the FastMCP server. Note this is a synchronous function.
 |      
 |      Args:
 |          transport: Transport protocol to use ("stdio", "sse", or "streamable-http")
 |  
 |  async run_async(self, transport: 'Transport | None' = None, show_banner: 'bool' = True, **transport_kwargs: 'Any') -> 'None'
 |      Run the FastMCP server asynchronously.
 |      
 |      Args:
 |          transport: Transport protocol to use ("stdio", "sse", or "streamable-http")
 |  
 |  async run_http_async(self, show_banner: 'bool' = True, transport: "Literal['http', 'streamable-http', 'sse']" = 'http', host: 'str | None' = None, port: 'int | None' = None, log_level: 'str | None' = None, path: 'str | None' = None, uvicorn_config: 'dict[str, Any] | None' = None, middleware: 'list[ASGIMiddleware] | None' = None, json_response: 'bool | None' = None, stateless_http: 'bool | None' = None) -> 'None'
 |      Run the server using HTTP transport.
 |      
 |      Args:
 |          transport: Transport protocol to use - either "streamable-http" (default) or "sse"
 |          host: Host address to bind to (defaults to settings.host)
 |          port: Port to bind to (defaults to settings.port)
 |          log_level: Log level for the server (defaults to settings.log_level)
 |          path: Path for the endpoint (defaults to settings.streamable_http_path or settings.sse_path)
 |          uvicorn_config: Additional configuration for the Uvicorn server
 |          middleware: A list of middleware to apply to the app
 |          json_response: Whether to use JSON response format (defaults to settings.json_response)
 |          stateless_http: Whether to use stateless HTTP (defaults to settings.stateless_http)
 |  
 |  async run_stdio_async(self, show_banner: 'bool' = True, log_level: 'str | None' = None) -> 'None'
 |      Run the server using stdio transport.
 |      
 |      Args:
 |          show_banner: Whether to display the server banner
 |          log_level: Log level for the server
 |  
 |  tool(self, name_or_fn: 'str | AnyFunction | None' = None, *, name: 'str | None' = None, title: 'str | None' = None, description: 'str | None' = None, icons: 'list[mcp.types.Icon] | None' = None, tags: 'set[str] | None' = None, output_schema: 'dict[str, Any] | NotSetT | None' = Ellipsis, annotations: 'ToolAnnotations | dict[str, Any] | None' = None, exclude_args: 'list[str] | None' = None, meta: 'dict[str, Any] | None' = None, enabled: 'bool | None' = None, task: 'bool | TaskConfig | None' = None) -> 'Callable[[AnyFunction], FunctionTool] | FunctionTool'
 |      Decorator to register a tool.
 |      
 |      Tools can optionally request a Context object by adding a parameter with the
 |      Context type annotation. The context provides access to MCP capabilities like
 |      logging, progress reporting, and resource access.
 |      
 |      This decorator supports multiple calling patterns:
 |      - @server.tool (without parentheses)
 |      - @server.tool (with empty parentheses)
 |      - @server.tool("custom_name") (with name as first argument)
 |      - @server.tool(name="custom_name") (with name as keyword argument)
 |      - server.tool(function, name="custom_name") (direct function call)
 |      
 |      Args:
 |          name_or_fn: Either a function (when used as @tool), a string name, or None
 |          name: Optional name for the tool (keyword-only, alternative to name_or_fn)
 |          description: Optional description of what the tool does
 |          tags: Optional set of tags for categorizing the tool
 |          output_schema: Optional JSON schema for the tool's output
 |          annotations: Optional annotations about the tool's behavior
 |          exclude_args: Optional list of argument names to exclude from the tool schema.
 |              Deprecated: Use `Depends()` for dependency injection instead.
 |          meta: Optional meta information about the tool
 |          enabled: Optional boolean to enable or disable the tool
 |      
 |      Examples:
 |          Register a tool with a custom name:
 |          ```python
 |          @server.tool
 |          def my_tool(x: int) -> str:
 |              return str(x)
 |      
 |          # Register a tool with a custom name
 |          @server.tool
 |          def my_tool(x: int) -> str:
 |              return str(x)
 |      
 |          @server.tool("custom_name")
 |          def my_tool(x: int) -> str:
 |              return str(x)
 |      
 |          @server.tool(name="custom_name")
 |          def my_tool(x: int) -> str:
 |              return str(x)
 |      
 |          # Direct function call
 |          server.tool(my_function, name="custom_name")
 |          ```
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  as_proxy(backend: 'Client[ClientTransportT] | ClientTransport | FastMCP[Any] | FastMCP1Server | AnyUrl | Path | MCPConfig | dict[str, Any] | str', **settings: 'Any') -> 'FastMCPProxy' from builtins.type
 |      Create a FastMCP proxy server for the given backend.
 |      
 |      The `backend` argument can be either an existing `fastmcp.client.Client`
 |      instance or any value accepted as the `transport` argument of
 |      `fastmcp.client.Client`. This mirrors the convenience of the
 |      `fastmcp.client.Client` constructor.
 |  
 |  from_fastapi(app: 'Any', name: 'str | None' = None, route_maps: 'list[RouteMap] | None' = None, route_map_fn: 'OpenAPIRouteMapFn | None' = None, mcp_component_fn: 'OpenAPIComponentFn | None' = None, mcp_names: 'dict[str, str] | None' = None, httpx_client_kwargs: 'dict[str, Any] | None' = None, tags: 'set[str] | None' = None, **settings: 'Any') -> 'FastMCPOpenAPI' from builtins.type
 |      Create a FastMCP server from a FastAPI application.
 |  
 |  from_openapi(openapi_spec: 'dict[str, Any]', client: 'httpx.AsyncClient', route_maps: 'list[RouteMap] | None' = None, route_map_fn: 'OpenAPIRouteMapFn | None' = None, mcp_component_fn: 'OpenAPIComponentFn | None' = None, mcp_names: 'dict[str, str] | None' = None, tags: 'set[str] | None' = None, **settings: 'Any') -> 'FastMCPOpenAPI' from builtins.type
 |      Create a FastMCP server from an OpenAPI specification.
 |  
 |  generate_name(name: 'str | None' = None) -> 'str' from builtins.type
 |  
 |  ----------------------------------------------------------------------
 |  Readonly properties defined here:
 |  
 |  docket
 |      Get the Docket instance if Docket support is enabled.
 |      
 |      Returns None if Docket is not enabled or server hasn't been started yet.
 |  
 |  icons
 |  
 |  name
 |  
 |  settings
 |  
 |  version
 |  
 |  website_url
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  instructions
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __annotations__ = {}
 |  
 |  __orig_bases__ = (typing.Generic[~LifespanResultT],)
 |  
 |  __parameters__ = (~LifespanResultT,)
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from typing.Generic:
 |  
 |  __class_getitem__(params) from builtins.type
 |      Parameterizes a generic class.
 |      
 |      At least, parameterizing a generic class is the *main* thing this method
 |      does. For example, for some generic class `Foo`, this is called when we
 |      do `Foo[int]` - there, with `cls=Foo` and `params=int`.
 |      
 |      However, note that this method is also called when defining generic
 |      classes in the first place with `class Foo(Generic[T]): ...`.
 |  
 |  __init_subclass__(*args, **kwargs) from builtins.type
 |      This method is called when a class is subclassed.
 |      
 |      The default implementation does nothing. It may be
 |      overridden to extend subclasses.

